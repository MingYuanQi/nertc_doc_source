<!--keywords:音视频通话,美颜,相芯,Faceunity Nama-->

网易云信 NERTC SDK 支持接入相芯等第三方专业美颜滤镜厂商，实现美颜、美妆、滤镜、贴纸等美颜特效。在娱乐社交、在线教育等场景中，您可以快速构建具备美颜特效能力的应用，让用户在进行视频通话或直播时，呈现更良好的肌肤状态和精神面貌。

相芯美颜（Faceunity Nama SDK，下文简称 Nama SDK）的详细功能介绍请参考 <a href="https://yunxin.163.com/face" target="_blank">人脸特效</a>。

<style>
table th:first-of-type {
    width: 35%;
}
</style>

## 准备工作

根据本文操作前，请确保您已经完成了以下设置：

1. [下载相芯美颜 SDK（推荐使用 V8.3.0 版本）](https://github.com/Faceunity/FULiveDemoDroid/releases)。
2. 获取相芯美颜 SDK 的证书，具体请联系网易云信商务经理。
3. 获取相芯美颜资源文件，具体请联系网易云信商务经理。
4. 集成 NERTC SDK，**推荐使用 NERTC V4.6.50 及以后版本**，V4.6.50 版本对相芯美颜进行了优化。

## 功能原理

<img alt="相芯美颜原理.png" src="https://yx-web-nosdn.netease.im/common/4989bbdcd8c7537e65727a3a517445bc/相芯美颜原理.png" style="width:50%;border: 1px solid #BFBFBF;">

1. NERTC SDK 提供了 <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_n_e_rtc_engine_video_frame_observer-p.html#a51b7f672806b1b307a7e116b5b5c62a0" target="_blank">`onNERtcEngineVideoFrameCaptured: rotation:`</a> 采集数据回调的接口，将采集到的视频图像数据通过该接口回调出来。

2. Nama SDK 通过回调获取视频图像数据，进行美颜处理后，通过参数返回给 NERTC SDK。

3. NERTC SDK 将美颜后的数据进行编码和传输。

## <span id="注意事项">注意事项</span>

- 该设置仅在加入房间之前设置才有效。
- 若 NERTC SDK 版本号低于 3.7.0，需要在初始化 NERTC SDK 之前调用 <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine-p.html#a2a674564c41bbd4b5556f08a9d65a558" target="_blank">`setParameters`</a> 方法。
- <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_n_e_rtc_engine_video_frame_observer-p.html#a51b7f672806b1b307a7e116b5b5c62a0" target="_blank">`onNERtcEngineVideoFrameCaptured: rotation:`</a> 回调必须同步返回，且保证 CVPixelBufferRef 的地址值不被改变，分辨率不改变。

## 示例项目源码

网易云信提供 [第三方美颜的示例项目源码](https://github.com/netease-im/G2-API-Examples/tree/main/ios/Advanced/ThirdBeauty)，您可以参考该源码实现第三方美颜。

## <span id="配置步骤">实现方法</span>

### 第一步：集成相芯美颜

1. 将证书文件 `authpack.h` 放到本地项目的 `Beauty` 目录下。

2. 将所需的美颜模型和道具放到本地项目的 `Resource` 目录下。
3. 通过 Cocoapods 集成相芯美颜 SDK。
    1. 在 podfile 中添加以下代码。
        ```
        pod 'Nama', '8.3.0'
        ```
    2. 在 terminal 中执行以下命令。

        ```
        pod install
        ```

### 第二步：初始化相芯美颜 SDK

```Objective-C
// 引入头文件（iOS）
#import <libCNamaSDK/FURenderer.h>

// 初始化
[[FURenderer shareRenderer] setupWithData:nil dataSize:0 ardata:nil authPackage:&g_auth_package authSize:sizeof(g_auth_package) shouldCreateContext:YES];

// 加载 AI 模型
NSData *ai_human_processor = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"ai_human_processor.bundle" ofType:nil]];
[FURenderer loadAIModelFromPackage:(void *)ai_human_processor.bytes size:(int)ai_human_processor.length aitype:FUAITYPE_HUMAN_PROCESSOR];
NSData *ai_face_processor = [NSData dataWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@"ai_face_processor.bundle" ofType:nil]];
[FURenderer loadAIModelFromPackage:(void *)ai_face_processor.bytes size:(int)ai_face_processor.length aitype:FUAITYPE_FACEPROCESSOR];

```

### 第三步：适配设备方向

NERTC 的 `onNERtcEngineVideoFrameCaptured` 回调中，默认会返回视频的方向信息，进行图像处理之前，需要先使用相芯接口配置方向信息，否则一些涉及人脸识别的功能会发生异常。

1. 创建 CMMotionManger，用于获取当前的设备方向。
    ```Objective-C
    self.motionManager = [[CMMotionManager alloc] init];
    self.motionManager.accelerometerUpdateInterval = 0.5;// 1s 刷新一次
    if ([self.motionManager isDeviceMotionAvailable]) {
        [self.motionManager startAccelerometerUpdates];
        [self.motionManager startDeviceMotionUpdates];
    }
    ```

2. 在每次进行图像处理之前，判断一下当前的设备方向，并调用相芯接口配置方向信息。
    ```Objective-C
    // 存储当前的设备方向，默认值为 0
    @property (nonatomic, assign) int deviceOrientation;

    // 获取设备方向
    CMAcceleration acceleration = self.motionManager.accelerometerData.acceleration;
    int orientation = 0;
    if (acceleration.x >= 0.75) {
        orientation = 1;
    } else if (acceleration.x <= -0.75) {
        orientation = 3;
    } else if (acceleration.y <= -0.75) {
        orientation = 0;
    } else if (acceleration.y >= 0.75) {
        orientation = 2;
    }

    // 根据设备方向来配置方向信息
    if (orientation == 0) {
        fuSetDefaultRotationMode(FU_ROTATION_MODE_270);
    } else if (orientation == 1) {
        fuSetDefaultRotationMode(FU_ROTATION_MODE_0);
    } else if (orientation == 2) {
        fuSetDefaultRotationMode(FU_ROTATION_MODE_90);
    } else {
        fuSetDefaultRotationMode(FU_ROTATION_MODE_180);
    }

    if (self.deviceOrientation != orientation) {
        self.deviceOrientation = orientation;

        // 若设备方向发生了变化，也需要通知相芯 SDK
        [FURenderer onCameraChange];
    }

    ```

### 第四步：视频图像处理

1. 调用 <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine-p.html#a2a674564c41bbd4b5556f08a9d65a558" target="_blank">`setParameters`</a> 接口，将 `kNERtcKeyVideoCaptureObserverEnabled` 的值设置为 YES，开启摄像头采集数据的回调。
2. 在成功加入房间后调用 <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine-p.html#a9f13beb56a8b9fdfbc856d304c0d10cb" target="_blank">`enableLocalVideo`</a> 方法开启本地视频采集。
    ::: note notice
    调用 <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine-p.html#a9f13beb56a8b9fdfbc856d304c0d10cb" target="_blank">`enableLocalVideo`</a> 开启本地视频采集时，请设置 `streamType` 为 `kNERtcStreamChannelTypeMainStream`，否则美颜效果不会生效。
    :::
3. 在代理方法 <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_n_e_rtc_engine_video_frame_observer-p.html#a51b7f672806b1b307a7e116b5b5c62a0" target="_blank">`onNERtcEngineVideoFrameCaptured:rotation:`</a> 中，将原始视频图像数据通过回调发给相芯美颜的接口，做相应的美颜处理。

4. 调用相芯美颜的 `renderPixelBuffer` 接口，从 NERTC 回调中获取原始视频图像数据，对视频图像数据进行美颜处理，美颜后的视频数据再通过参数返回给 NERTC 代理。该接口中的相关参数说明如下表所示。

    参数 | 说明
    ---- | ----
    pixelBuffer | 将 NERtc SDK 回调的每帧 pixelBuffer 图像，直接传入进行处理。
    frameid | 需要开发者自行维护，每调用完该接口就要 +1，否则无法驱动其中的特效动画。
    items | 各种类型资源的 ID，默认情况下没有创建资源时，数组中的 ID 值为 0。

**示例代码**

```Objective-C
NERtcEngine *coreEngine = [NERtcEngine sharedEngine];

//初始化
NERtcEngineContext *context = [[NERtcEngineContext alloc] init];
context.engineDelegate = self;
context.appKey = @"<#请输入您的 AppKey#>";
[coreEngine setupEngineWithContext:context];

// 配置音视频引擎,将摄像头采集的数据回调给用户
NSDictionary *params = @{
    kNERtcKeyVideoCaptureObserverEnabled: @YES // 将摄像头采集的数据回调给用户
};
[coreEngine setParameters:params];

//开启本地视频采集
[coreEngine enableLocalVideo:YES streamType:kNERtcStreamChannelTypeMainStream];

// 在代理方法中对视频数据进行处理
- (void)onNERtcEngineVideoFrameCaptured:(CVPixelBufferRef)bufferRef rotation:(NERtcVideoRotationType)rotation
{
    // 对视频数据 bufferRef 进行处理, 务必保证 CVPixelBufferRef 的地址值不变，分辨率不变
}
```

### 第五步：设置美颜效果

美颜、美妆、滤镜、贴纸效果的具体参数设置，请参考 [Faceunity Nama 相关文档](https://github.com/Faceunity/FULiveDemo/tree/master/docs)。

### 第六步：管理美颜资源

关于管理美颜资源的建议如下：

- 各种类型资源的 ID，在创建时由相芯美颜 SDK 的接口返回，因此在集成时定义一个枚举来区分各种类型的资源，会更加方便维护。
    ```Objective-C
    typedef NS_ENUM(NSUInteger, FUNamaHandleType) {
        FUNamaHandleTypeBeauty = 0, /* items[0] ---- 美颜道具句柄 */
        FUNamaHandleTypeItem = 1,   /* items[1] ---- 普通道具句柄（包含很多，如 贴纸，aoimoji...若不单一存在，可放句柄集其他位置） */
        FUNamaHandleTypeFxaa = 2,   /* items[2] ---- fxaa 抗锯齿道具句柄 */
        FUNamaHandleTypeMakeupLight = 3, /* items[3] ---- 质感美颜 */
        FUNamaHandleTypeMakeup = 4,   /* items[4] ---- 美妆道具句柄 */
    };

    static NSUInteger const kFUNamaHandleCount = 5;

    int m_fuItems[kFUNamaHandleCount];
    ```

- 除了美颜道具可以长期持有，其他道具例如贴纸、animoji、AR 面具等都属于普通道具，因此使用时，需要创建新的道具，再销毁同类型的其他道具。

    ```Objective-C
    // 创建美颜相关资源
    NSString *beautyPath = [[NSBundle mainBundle] pathForResource:@"face_beautification" ofType:@"bundle"];
    m_fuItems[FUNamaHandleTypeBeauty] = [FURenderer itemWithContentsOfFile:beautyPath];
    ```

## 相关文档

如果您使用呼叫组件集成 NERTC，集成相芯美颜的方法请参考 <a href="https://doc.yunxin.163.com/nertccallkit/docs/DQ3NTExNDU?platform=iOS" target="_blank">集成呼叫组件和第三方美颜</a>。

## API 参考

| **方法** | **功能描述** |
| :-- | :-- |
| <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine-p.html#a9f13beb56a8b9fdfbc856d304c0d10cb" target="_blank">`enableLocalVideo`</a> | 开启本地视频采集。 |
| <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_i_n_e_rtc_engine-p.html#a2a674564c41bbd4b5556f08a9d65a558" target="_blank">`setParameters`</a> | 设置摄像头采集数据的回调。 |
| <a href="https://doc.yunxin.163.com/nertc/references/iOS/doxygen/Latest/zh/html/protocol_n_e_rtc_engine_video_frame_observer-p.html#a51b7f672806b1b307a7e116b5b5c62a0" target="_blank">`onNERtcEngineVideoFrameCaptured:rotation:`</a> | 视频帧数据回调。 |

## 常见问题

### iOS 支持的最低系统版本是多少？

推荐使用 iOS 9.0 及以上版本。

### OpenGL ES 环境需要如何配置？

在初始化方法 `setupWithData` 中，最后一个参数 `shouldCreateContext` 建议设为 `YES`。这样的话相芯 SDK 会创建专属的 context，保持渲染资源与 NERTC SDK 相互独立，避免相互影响。

### 使用美颜后画面会闪一下，怎么办？

- **可能原因**：相芯 7.x.x 版本 SDK 前 5 帧存在渲染问题。

- **解决方案**：

    - 升级相芯版本至 8.x.x 版本。
    - 若不想升级相芯版本，在美颜处理时，建议您丢弃前 5 帧。

### 使用美颜后画面出现闪屏、黑屏，怎么办？

- **可能原因**：美颜拿到了采集的过程数据没拿到结果数据。
- **解决方案**：
    - 初始化相芯 SDK 时，调用 `fuSetUseTexAsync(true)` 方法。
    - 升级 NERTC SDK 至 4.6.50 及以后的版本。详情请参考 [升级指南](https://doc.yunxin.163.com/nertc/guide/jc5OTQ1NDU?platform=iOS)。

### 使用美颜后出现画面卡顿，怎么办？

- **可能原因 1**：采集帧率设置太高，例如 30 帧，美颜也会按照 30 帧率进行处理。在一些低端机上，高帧率会对整个系统产生较大的压力，美颜处理时间可能会超过每一帧预期的帧间隔，引发画面卡顿。
- **解决方案**：降低采集帧率，在 NERTC SDK 的视频配置中，将帧率设置为 15。

- **可能原因 2**：相芯 SDK 日志级别太低，导致每处理一帧都会打印大量日志，影响整体性能。
- **解决方案**：在初始化时，关闭相芯 SDK 日志，将日志级别设置为 `OFF`。

    ```Objective-C
    [FURenderKit setLogLevel:FU_LOG_LEVEL_OFF];
    ```

### FURenderKit 与 CNamaSDK 推荐使用哪个？

更推荐使用 FURenderKit，前期集成与后期维护更方便，且能提供高性能渲染和复杂的视觉效果。