本地录制是指在本地设备上进行音视频流的录制过程。用户在本地设备上，通过摄像头和麦克风获取视频和音频信号，从而采集音视频数据。您可以对录制的音视频流进行布局配置，如设置视频窗口的位置、大小、缩放模式等，以满足不同的录制需求和视觉效果。本地录制功能在诸如会议记录、在线教育、视频存档、监控录像等场景中被频繁运用。

本文介绍如何使用网易云信音视频通话 2.0（NERTC）本地录制引擎提供的接口，实现对音视频流的录制、布局配置、转码等功能。通过合理调用接口，您可以轻松完成录制任务的创建、管理与优化。

## 功能特点

因为本地录制是在本地设备上进行音视频流的录制的，因此具有以下特点：

- **独立性**：本地录制不依赖于外部网络或服务器，即使在网络不稳定或无网络的情况下，也能正常进行录制。
- **安全性**：录制的数据存储在本地设备上，数据传输距离短，不易受到网络攻击和数据泄露的风险，具有较高的安全性。
- **灵活性**：用户可以根据需要灵活地配置录制参数和布局，满足多样化的录制场景和需求。
- **实时性**：录制过程在本地实时进行，不需要依赖网络传输，能够快速响应用户的操作和需求。可以实时获取和控制录制数据，便于进行实时处理和分析，如实时监控、实时教学等。

## 应用场景

相比较云端录制和本地服务端录制，本地录制适用以下场景：

- **离线环境**：如在无网络覆盖的偏远地区或封闭的会议室等环境中进行录制。
- **数据敏感**：对于涉及商业机密、个人隐私或其他敏感信息的录制内容，需要确保数据不外泄。
- **实时处理**：需要对录制数据进行实时分析、处理或反馈的场景，如实时监控、实时教学等。
- **小规模录制**：录制规模较小，对设备性能要求不高的场景，如个人视频创作、小型会议记录等。

如果您有大规模直播、跨地域协同办公、视频后期处理、数据共享与并发的录制需求，建议您使用 [云端录制](https://doc.yunxin.163.com/nertc/server-apis/zE4NDg0NTM?platform=server) 功能。如果您有金融面签、在线会议、远程教育、在线医疗等行业场景的录制需求，建议您使用 [本地服务端录制](https://doc.yunxin.163.com/nerecord/concept/TE4MDU5NDE?platform=linux)。

<!-- **云端录制适用场景**：

- **大规模直播**：如大型体育赛事、演唱会等直播活动，需要高并发和高可用的录制服务。
- **跨地域协作**：多地协同办公、远程教育等场景，需要将录制内容实时同步到不同地点。
- **后期处理需求**：录制完成后需要进行复杂的后期处理，如视频剪辑、特效制作等，利用云端的强大计算能力。
- **数据共享与分发**：需要将录制内容快速分发给大量用户或进行多平台共享的场景，如在线教育平台、视频会议系统等。-->

## 完整示例

NERTC 本地录制引擎的接口使用完整示例如下所示：

```C++
IRtcEngineEx* rtc_engine_ = (IRtcEngineEx *)createNERtcEngine();

// 创建录制配置
NERtcLocalRecordingConfig record_config;
record_config.file_path = "D://LocalRecord/";
record_config.file_name = "netease";
record_config.width = 1280;
record_config.height = 720;
record_config.framerate = 15;
record_config.record_file_type = kNERtcLocalRecordingFileTypeFlv;
record_config.remux_to_mp4 = true;
record_config.video_merge = true;
record_config.record_video = true;
record_config.record_audio = false;
record_config.audio_format = kNERtcLocalRecorderAudioFormatAac;
record_config.video_record_mode = kNERtcLocalRecorderVideoWithAudio;
record_config.cover_file_path = "D://cover.png";
record_config.default_cover_file_path = "D://placeholder.png";

// 创建水印配置
int water_mark_config_cnt = 2;
NERtcVideoWatermarkConfig* water_mark_config = new NERtcVideoWatermarkConfig[water_mark_config_cnt];
record_config.watermark_list = water_mark_config;
record_config.watermark_count = water_mark_config_cnt;

int cover_water_mark_config_cnt = 2;
NERtcVideoWatermarkConfig* cover_water_mark_config = new NERtcVideoWatermarkConfig[cover_water_mark_config_cnt];
record_config.cover_watermark_list = cover_water_mark_config;
record_config.cover_watermark_count = cover_water_mark_config_cnt;

char* task_id = "netease_record";

// 增加一个录制任务
rtc_engine_->addLocalRecorderStreamForTask(record_config, task_id);

// 为录制任务增加一路流
NERtcLocalRecordingLayoutConfig layout;
layout.offset_x = 100;
layout.offset_y = 100;
layout.width = 320;
layout.height = 160;
layout.scaling_mode = kNERtcVideoScaleFullFill;
layout.watermark_list = nullptr;
layout.watermark_count = 0;
layout.is_screen_share = false;
layout.bg_color = 0;
rtc_engine_->addLocalRecorderStreamLayoutForTask(layout, 163, kNERTCVideoStreamMain, 0, task_id);

// 批量更新已添加录制视频流的布局信息
int infos_count = 2;
NERtcLocalRecordingStreamInfo* stream_infos = new NERtcLocalRecordingStreamInfo[infos_count];
rtc_engine_->updateLocalRecorderStreamLayoutForTask(stream_infos, infos_count, task_id);

// 批量替换添加的录制视频的布局信息
int infos_count = 2;
NERtcLocalRecordingStreamInfo* stream_infos = new NERtcLocalRecordingStreamInfo[infos_count];
rtc_engine_->replaceLocalRecorderStreamLayoutForTask(stream_infos, infos_count, task_id);

// 通过接口向录制引擎中 push 视频流
NERtcVideoFrame frame;
rtc_engine_->pushLocalRecorder
VideoFrameForTask(163, kNERTCVideoStreamSub, 0, task_id, &frame);

// 录制过程中某一路无视频流时调用该接口实现显示默认占位图
rtc_engine_->showLocalRecorderStreamDefaultCoverForTask(true, 163, kNERTCVideoStreamMain, 0, task_id);

// 为录制任务删除一路流
rtc_engine_->removeLocalRecorderStreamLayoutForTask(163, kNERTCVideoStreamMain, 0, task_id);

// 删除录制任务
rtc_engine_->removeLocalRecorderStreamForTask(task_id);

// 删除录制任务时开启进行 FLV 转 MP4 工作，此时如果不等待转换则需调用该接口，调用该接口后停止转换 MP4 且已转码的 MP4 文件会被删除
rtc_engine_->stopLocalRecorderRemuxMp4(task_id);

// 对于文件夹中存在的 FLV 文件，可以使用该接口转换为 MP4 文件，同时只可转换一个文件
std::string flv_path = "D:/localrecord/netease.flv";
std::string mp4_path = "D:/localrecord/netease.mp4";
bool save_ori = false;
rtc_engine_->remuxFlvToMp4(flv_path, mp4_path, save_ori);

// 停止转 MP4 文件
rtc_engine_->stopRemuxFlvToMp4();
```

## 主要接口

### 添加本地录制流任务

- **功能**：创建一个新的本地录制任务。
- **接口**：[`addLocalRecorderStreamForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a423faa49f1bd4e92a1e70ba2fd6f149c)
<!-- - **参数**：
    - **`config`**：录制配置，包括文件路径、分辨率、帧率等。
    - **`task_id`**：录制任务 ID，用于唯一标识该任务。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    NERtcLocalRecordingConfig record_config;
    record_config.file_path = "D://LocalRecord/";
    record_config.file_name = "netease";
    // 设置其他配置项...
    char* task_id = "netease_record";
    int result = rtc_engine_->addLocalRecorderStreamForTask(record_config, task_id);
    if (result == 0) {
        // 添加成功
    } else {
        // 处理错误
    }
    ```

### 移除本地录制流任务

- **功能**：删除已创建的本地录制任务。
- **接口**：[`removeLocalRecorderStreamForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a1d4cd1dfa08cd6e17479c479257eb7e6)
<!-- - **参数**：
    - **`task_id`**：要删除的录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：

    ```C++
    char* task_id = "netease_record";
    int result = rtc_engine_->removeLocalRecorderStreamForTask(task_id);
    if (result == 0) {
        // 删除成功
    } else {
        // 处理错误
    }
    ```

### 添加指定用户的指定流的录制流布局

- **功能**：为特定用户和流类型设置录制流的布局。
- **接口**：[`addLocalRecorderStreamLayoutForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a248a79b9fd1a2364371e21571800e617)
<!-- - **参数**：
    - **`config`**：录制流布局配置，包括偏移、分辨率、缩放模式等。
    - **`uid`**：用户 ID。
    - **`stream_type`**：流类型（如主视频流、辅视频流）。
    - **`stream_layer`**：流的录制混流层级。
    - **`task_id`**：录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    NERtcLocalRecordingLayoutConfig layout;
    layout.offset_x = 100;
    layout.offset_y = 100;
    layout.width = 320;
    layout.height = 160;
    // 设置其他配置项...
    int result = rtc_engine_->addLocalRecorderStreamLayoutForTask(layout, 163, kNERTCVideoStreamMain, 0, task_id);
    if (result == 0) {
        // 添加成功
    } else {
        // 处理错误
    }
    ```

### 移除指定用户的指定流的录制流布局

- **功能**：删除特定用户和流类型的录制流布局。
- **接口**：[`removeLocalRecorderStreamLayoutForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#ac531a67addd97a5a19fc7d541da68cca)
<!-- - **参数**：
    - **`uid`**：用户 ID。
    - **`stream_type`**：流类型。
    - **`stream_layer`**：流的录制混流层级。
    - **`task_id`**：录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    int result = rtc_engine_->removeLocalRecorderStreamLayoutForTask(163, kNERTCVideoStreamMain, 0, task_id);
    if (result == 0) {
        // 删除成功
    } else {
        // 处理错误
    }
    ```

### 更新指定用户的指定流的录制流布局

- **功能**：批量更新已添加录制视频流的布局信息。
- **接口**：[`updateLocalRecorderStreamLayoutForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#aa019c3fedfd6a1c616a073bd2ef828fa)
<!-- - **参数**：
    - **`infos`**：录制流布局配置数组指针。
    - **`infos_count`**：数组长度。
    - **`task_id`**：录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    int infos_count = 2;
    NERtcLocalRecordingStreamInfo* stream_infos = new NERtcLocalRecordingStreamInfo[infos_count];
    // 设置布局信息...
    int result = rtc_engine_->updateLocalRecorderStreamLayoutForTask(stream_infos, infos_count, task_id);
    if (result == 0) {
        // 更新成功
    } else {
        // 处理错误
    }
    ```

### 替换指定用户的指定流的录制流布局

- **功能**：批量替换添加的录制视频的布局信息。
- **接口**：[`replaceLocalRecorderStreamLayoutForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#ab9e498561ab266ef57d963964aea3a2c)
<!-- - **参数**：
    - **`infos`**：录制流布局配置数组指针。
    - **`infos_count`**：数组长度。
    - **`task_id`**：录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    int infos_count = 2;
    NERtcLocalRecordingStreamInfo* stream_infos = new NERtcLocalRecordingStreamInfo[infos_count];
    // 设置布局信息...
    int result = rtc_engine_->replaceLocalRecorderStreamLayoutForTask(stream_infos, infos_count, task_id);
    if (result == 0) {
        // 替换成功
    } else {
        // 处理错误
    }
    ```

### 推送本地录制视频帧

- **功能**：向录制引擎中推送视频帧数据。
- **接口**：[`pushLocalRecorderVideoFrameForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#aac2745859dab8492f162d9910a635ab6)
<!-- - **参数**：
    - **`uid`**：用户 ID。
    - **`stream_type`**：流类型。
    - **`stream_layer`**：流的录制混流层级。
    - **`task_id`**：录制任务 ID。
    - **`frame`**：视频帧数据。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    NERtcVideoFrame frame;
    // 设置视频帧数据...
    int result = rtc_engine_->pushLocalRecorderVideoFrameForTask(163, kNERTCVideoStreamSub, 0, task_id, &frame);
    if (result == 0) {
        // 推送成功
    } else {
        // 处理错误
    }
    ```

### 显示录制默认封面

- **功能**：在录制过程中某一路无视频流时，显示默认占位图。
- **接口**：[`showLocalRecorderStreamDefaultCoverForTask`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a45e923ade86e3b041522be8b410b46e5)
<!-- - **参数**：
    - **`show_enabled`**：是否显示封面。
    - **`uid`**：用户 ID。
    - **`stream_type`**：流类型。
    - **`stream_layer`**：流的录制混流层级。
    - **`task_id`**：录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    int result = rtc_engine_->showLocalRecorderStreamDefaultCoverForTask(true, 163, kNERTCVideoStreamMain, 0, task_id);
    if (result == 0) {
        // 显示成功
    } else {
        // 处理错误
    }
    ```

### 停止录制文件转码为 MP4

- **功能**：停止将录制文件转码为 MP4 格式。
- **接口**：[`stopLocalRecorderRemuxMp4`](https://doc.yunxin.163.com/nertc/references/windows/doxygen/Latest/zh/html/classnertc_1_1_i_rtc_engine_ex.html#a115e5599310219d54897737b12feafe7)
<!-- - **参数**：
    - **`task_id`**：录制任务 ID。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    int result = rtc_engine_->stopLocalRecorderRemuxMp4(task_id);
    if (result == 0) {
        // 停止成功
    } else {
        // 处理错误
    }
    ```

### 将 FLV 转码为 MP4

- **功能**：将 FLV 文件转码为 MP4 文件。
- **接口**：`remuxFlvToMp4`
<!-- - **参数**：

      - **`flv_path`**：FLV 文件路径。
      - **`mp4_path`**：输出 MP4 文件路径。
      - **`save_ori`**：是否保留原始 FLV 文件。
- **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：
    ```C++
    std::string flv_path = "D:/localrecord/netease.flv";
    std::string mp4_path = "D:/localrecord/netease.mp4";
    bool save_ori = false;
    int result = rtc_engine_->remuxFlvToMp4(flv_path, mp4_path, save_ori);
    if (result == 0) {
        // 转码成功
    } else {
        // 处理错误
    }
    ```

### 停止将 FLV 转码为 MP4

- **功能**：停止 FLV 转 MP4 的转码过程。
- **接口**：`stopRemuxFlvToMp4`
<!-- - **返回值**：
    - **`0`**：方法调用成功。
    - **其他值**：调用失败。 -->
- **示例代码**：

    ```C++
    int result = rtc_engine_->stopRemuxFlvToMp4();
    if (result == 0) {
        // 停止成功
    } else {
        // 处理错误
    }
    ```

## 回调枚举

### 录制状态

- **kNERtcLocalRecorderStatusNone**：无状态。
- **kNERtcLocalRecorderStatusFlvStart**：开始录制 FLV。
- **kNERtcLocalRecorderStatusFlvEnd**：结束录制 FLV。
- **kNERtcLocalRecorderStatusMp4Start**：开始录制 MP4。
- **kNERtcLocalRecorderStatusMp4End**：结束录制 MP4。
- **kNERtcLocalRecorderStatusRemuxStart**：开始 FLV 转码 MP4。
- **kNERtcLocalRecorderStatusRemuxEnd**：结束 FLV 转码 MP4。
- **kNERtcLocalRecorderStatusComplete**：录制任务完成。

### 录制错误码

- **kNERtcLocalRecorderErrorNone**：无错误。
- **kNERtcLocalRecorderFileOpenFailed**：打开录制文件路径失败。
- **kNERtcLocalRecorderWriteFailed**：录制流写入失败。
- **kNERtcLocalRecorderWriteTrailerFailed**：录制 Trailer 写入失败。
- **kNERtcLocalRecorderFailed**：录制任务最终失败。
- **kNERtcLocalRecorderCallbackConflict**：录制视频编码后码流回调重复注册。
- **kNERtcLocalRecorderTaskAlreadyExist**：录制任务已存在。
- **kNERtcLocalRecorderTaskNotFound**：录制任务未发现。
- **kNERtcLocalRecorderSourceNotFoundForTask**：录制视频源未发现。
- **kNERtcLocalRecorderInputOpenFailed**：转码输入文件打开失败。
- **kNERtcLocalRecorderVideoStreamCreateFailed**：录制视频流创建失败。
- **kNERtcLocalRecorderAudioStreamCreateFailed**：录制音频流创建失败。
- **kNERtcLocalRecorderCoverImageParseFailed**：录制封面图片解析失败。
- **kNERtcLocalRecorderPlaceholderImageParseFailed**：录制占位图解析失败。
- **kNERtcLocalRecorderAudioConfigInvalid**：录制音频配置不可用。
- **kNERtcLocalRecorderRemuxPrcocessRunning**：FLV 转码 MP4 任务已经启动，不能再新增一个任务。
- **kNERtcLocalRecorderOutputOpenFailed**：录制输出文件打开失败。

## 录制配置

### 录制布局配置

- **offset_x**：流在录制视频窗口的偏移宽度。
- **offset_y**：流在录制视频窗口的偏移高度。
- **width**：流在录制视频窗口的分辨率宽度。
- **height**：流在录制视频窗口的分辨率高度。
- **scaling_mode**：流在录制视频窗口的缩放模式。
- **watermark_list**：录制水印配置。
- **watermark_count**：录制水印数量。
- **is_screen_share**：是否是屏幕共享流。
- **bg_color**：录制视频窗口的背景颜色 ARGB 格式。

### 录制视频源信息

- **uid**：用户 ID。
- **stream_type**：流类型。
- **stream_layer**：流的录制混流层级。
- **layout_config**：录制视频窗口流的布局配置。

### 录制文件类型

- **kNERtcLocalRecordingFileTypeMp4**：Mp4 格式。
- **kNERtcLocalRecordingFileTypeFlv**：Flv 格式。可支持转成 Mp4。

### 录制视频模式选择

- **kNERtcLocalRecorderVideoWithAudio**：视频中带音频。
- **kNERtcLocalRecorderVideoWithoutAudio**：视频中不带音频。

### 录制纯音频格式

- **kNERtcLocalRecorderAudioFormatAac**：AAC 格式。

### 录制任务配置

- **file_path**：录制文件的路径。
- **file_name**：录制文件的名称。
- **width**：录制视频文件的分辨率宽度。
- **height**：录制视频文件的分辨率高度。
- **framerate**：录制视频文件的帧率。
- **record_file_type**：录制文件的类型。
- **remux_to_mp4**：录制文件为 FLV 时，是否转码为 MP4。
- **video_merge**：支持视频合并混流。
- **record_audio**：录制音频文件。
- **audio_format**：录制音频文件的格式。
- **record_video**：录制视频文件。
- **video_record_mode**：录制视频文件的模式。
- **watermark_list**：录制水印配置。
- **watermark_count**：录制水印数量。
- **cover_file_path**：录制封面配置。
- **cover_watermark_list**：录制封面水印配置。
- **cover_watermark_count**：录制封面水印数量。
- **default_cover_file_path**：录制默认封面配置。