<!--keywords:音视频通话,纯传输通道,编码后数据传输,裸流传输 -->

在一些需要与硬件配合的应用场景中，比如使用教室硬件设备进行线上教学，在利用硬件自身能力进行音频采集、编码的基础上，还需要良好的抗弱网传输能力。若您拥有第三方音频编解码模块或有能力自研编解码，为了实现实时音频码流传输互通，NERTC SDK 为您提供抗弱网、抗丢包的纯传输通道。

## 功能介绍

依托网易云信底层实时传输网络 WE-CAN（Communication Acceleration Network），NERTC 运用全球节点及抗弱网算法，提供低延时、高稳定性的音视频码流传输通道，大大减少延时、丢包等网络问题对音视频传输质量和体验的影响。

NERTC SDK 支持音频裸流传输，您可以向 NERTC SDK 提供自定义的 OPUS 等格式的音频编码数据，并由 NERTC SDK 进行推流。

## 注意事项

使用 NERTC SDK 提供的裸流传输通道时，您需要自行管理音频流的采集、编解码、渲染和其他处理。

## 发送音频裸流

### 实现方法

1. 在加入房间前，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#adcf058872a35042cd4e6d13685f17746" target="_blank">`SetExternalAudioSource`</a> 方法开启外部音频主流或辅流输入，并设置外部音频采集参数，相关参数说明如下：
    - enabled：是否开启外部音频输入，默认关闭。
    - sampleRate：外部音频源的数据采样率，单位为赫兹（Hz）。建议设置为 8000，16000，32000，44100 或 48000。
    - channels：外部音频源的数据声道数，可设置为单声道（1）或双声道（2）。
    ::: note note
    自定义外部音频采集接口只能在通话前调用，接口设置在通话结束后仍然有效；若您需要关闭该功能，请在下次通话前再次调用此方法关闭自定义音频采集。
    :::
2. 调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#ad77d62e1f5239937035820f557cb84f4" target="_blank">`EnableLocalAudio`</a> 开启媒体主流或辅流传输通道。 
    ::: note notice
    若您开启的是外部音频主流输入，请开启对应的媒体主流传输通道。
    :::
3. 您需要自行处理音频数据的采集与编码。
4. 调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#aeb469e5f4654bf98c7126525d4e7cc7e" target="_blank">`PushExternalAudioEncodedFrame`</a> 方法推送外部音频主流或辅流编码帧或调用，并通过 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/structnertc_1_1_rtc_audio_encoded_frame.html" target="_blank">`RtcAudioEncodedFrame`</a> 设置编码后的音频数据，包括音频数据类型、数据长度、声道数、样本数等。
    ::: note notice
    建议在推送外部音频编码帧时，不要调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#aeb469e5f4654bf98c7126525d4e7cc7e" target="_blank">`PushExternalAudioEncodedFrame`</a>方法同时推送主辅流编码帧。
    :::
### 示例代码

以实现音频主流编码帧传输为例，示例代码如下：
```
    IRtcEngine rtcEngine = IRtcEngine.GetInstance();

    //设置云代理
    private void PushExternalAudioEncodedFrame()
    {
        string token = "";//YOUR TOKEN
        string channelName = "YOUR CHANNEL NAME";
        ulong uid = 111;//YOUR UID

        //以主流为例
        // 开启外部音频源
        RtcAudioStreamType streamType = RtcAudioStreamType.kNERtcAudioStreamTypeMain;
        rtcEngine.SetExternalAudioSource(streamType, true, 16000, 1);

        // 入会
        rtcEngine.JoinChannel(token, channelName, uid);

        //打开音频发送
        rtcEngine.EnableLocalAudio(streamType,true);

        // 推送外部音频编码帧
        int timediff = 20; // ms, opus need 20ms
        ulong encoded_audio_ts = 0;
        DateTime last = DateTime.Now;
        DateTime now = last;
        int sampleRate = 48000;//采样率
        int channels = 2;//通道数
        int samplesPerchannel = sampleRate * timediff / 1000;
        while (true)
        {
            now = DateTime.Now;
            long gap = (long)((now -last).TotalMilliseconds);//us
            if (gap >= timediff)
            {
                last = now - TimeSpan.FromTicks((gap - timediff) * 10);
                var audioFrame = new RtcAudioEncodedFrame
                {
                    sampleRate = sampleRate,
                    channels = channels,
                    samplesPerchannel = samplesPerchannel,
                    payloadType = RtcAudioPayloadType.kNERtcAudioPayloadTypeOPUS,
                    encodedLength = len,//编码长度
                    data = data,//数据地址
                    rmsLevel = rmsLevel,// 音量标记
                    timestamp = timestamp_us,//机器时间，us
                    encodedTimestamp = (int)encoded_audio_ts, // 编码时间, 单位为样本数

                };
                encoded_audio_ts += (ulong)audioFrame.samplesPerchannel;
                rtcEngine.PushExternalAudioEncodedFrame(streamType, ref audioFrame);

            }
            Thread.Sleep(1);
        }
    }
}
```

## 接收音频裸流

### 实现方法

1. 在初始化后，调用 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#ab12fc5912f5474b1672acab95317ac97" target="_blank">`SetPreDecodeObserver`</a> 注册解码前媒体数据观测器。

2. 远端发送音频流后，SDK 触发 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/interfacenertc_1_1_i_predecode_frame_observer.html#ad6cc1bd1b142a03b1f55ccf19a1fd8f0" target="_blank">`OnFrame`</a> 回调，通过 <a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/structnertc_1_1_rtc_predecode_frame_info.html" target="_blank">`predecodeFrame`</a> 参数返回相关解码前媒体数据，包括用户的 UID、媒体数据类型、数据长度、音频帧数据时间间隔等。

3. 您需要自行处理音频数据的解码与渲染。

### 示例代码
```
    // 设置解码前数据回调观测器
    public class MyClass : IPredecodeFrameObserver
    {
        IRtcEngine rtcEngine = IRtcEngine.GetInstance();
        public void OnFrame(ref RtcPredecodeFrameInfo predecodeFrame)
        {
            //TODO:
        }

        private void setPreDecodeObserver()
        {
            rtcEngine.SetPreDecodeObserver(this);
        }
    }
```

## API 参考

| **方法** | **功能描述**|
|:--|:--|
|<a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#adcf058872a35042cd4e6d13685f17746" target="_blank">`SetExternalAudioSource`</a> | 开启外部音频主流或辅流输入|
|<a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#aeb469e5f4654bf98c7126525d4e7cc7e" target="_blank">`PushExternalAudioEncodedFrame`</a>| 推送外部音频主流或辅流编码帧|
|<a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/classnertc_1_1_i_rtc_engine.html#ab12fc5912f5474b1672acab95317ac97" target="_blank">`SetPreDecodeObserver`</a>|注册解码前媒体数据观测器|


| **事件** | **事件描述** |
|:--|:--|
|<a href="https://doc.yunxin.163.com/nertc/api-refer/unity/doxygen/V5.4.5/zh/html/interfacenertc_1_1_i_predecode_frame_observer.html#ad6cc1bd1b142a03b1f55ccf19a1fd8f0" target="_blank">`OnFrame`</a>|解码前媒体数据回调|